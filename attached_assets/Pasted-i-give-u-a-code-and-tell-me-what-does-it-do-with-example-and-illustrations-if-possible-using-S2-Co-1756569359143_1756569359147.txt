i give u a code and tell me what does it do, with example and illustrations if possible: using S2.Core.Controls; using S2.Core.Utils; using S2.CA.DataFactory; using S2.CA.Entities; using System; using System.Collections.Generic; using Wisej.Web; using S2.Core.Entities; using S2.Core.DataFactory; using S2.CA.Controls; using System.Linq; using S2.CA.Promigas.BLT; namespace S2.CA.Promigas.Modules { public partial class UCTransportTax : ModuleBase { #region Private Fields private DateTime? _mcStartDate; BLT_Network _bltNetwork; List<BLT_Line> _lines; List<CA_LinePointFlow> _flows; List<CA_Point> _points; const string CLASS_NAME = "VolumeTransportTax"; BLT_TransportTax _bltTransportTax; #endregion #region Public Properties #endregion #region Constructors public UCTransportTax() { InitializeComponent(); } #endregion #region Public Methods #endregion #region Private Methods private void LoadData(int networkId, DateTime dStart) { dgv.Rows.Clear(); _bltNetwork = new BLT_Network(); _lines = new List<BLT_Line>(); // _bltNetwork.GetLines(networkId, dStart); _flows = CA_LinePointFlowFactory.Instance.GetList(networkId, dStart); _points = CA_PointFactory.Instance.GetAllObjects(); List<BLT_Line> trunklines = _bltNetwork.GetTrunkline(networkId).OrderBy(o=> o.Line.SortOrder).ToList(); foreach (BLT_Line trunkline in trunklines) { _lines.AddRange(_bltNetwork.GetLines(trunkline, dStart)); AddLineFlows(trunkline); } dgv.SetPagerInfo(dgv.Rows.Count); } private void SetUnits() { dgv.ColumnHeadersHeight = 40; dgv.ColumnHeadersDefaultCellStyle.WrapMode = DataGridViewTriState.True; colPointType.DefaultCellStyle.Alignment = DataGridViewContentAlignment.MiddleCenter; dgv.SetUnit(colFromPrevPoint, "FromPrevPoint", CLASS_NAME); dgv.SetUnit(colVolumeChange, "VolumeChange", CLASS_NAME); dgv.SetUnit(colVolumePassThru, "VolumePassThru", CLASS_NAME); dgv.SetUnit(colOriginalInjection, "OriginalInjection", CLASS_NAME); } #endregion #region Control Event Methods private void btnQuery_Click(object sender, EventArgs e) { int? networkId = cmbNetwork.GetSelectedId<CA_Network>(); if (networkId == null) return; Period period = (Period)cmbPeriod.Items[cmbPeriod.SelectedIndex]; LoadData(networkId.Value, period.StartTime); } #endregion protected override void InitControl() { base.InitControl(); cmbNetwork.Bind<CA_Network>(CA_NetworkFactory.Instance.GetAllObjects("Name")); //Boolean recalcAccess = Sys.UserAuthorityCache.HasAuthorityWithOrgId(Sys.UserAuthorityCache.MasterOrganizationId, CA_Authority.EditBilling); bool recalcAccess = Sys.UserAuthorityCache.HasAuthority(CA_Authority.EditTransportTax); btnRecalc.Visible = recalcAccess; btnRecalc.Enabled = recalcAccess; SetUnits(); dgv.CellDoubleClick += Dgv_CellDoubleClick; // Initialize period selection box DateTime start = DateTime.Parse("2000-1-1"); DateTime end = DateTime.Parse("2050-1-1"); _bltTransportTax = new BLT_TransportTax(); List<Period> periodList = PeriodFactory.Instance.GetPeriods(_bltTransportTax.Calendar.Id, start, end, PeriodGranularity.QUARTERLY); periodList.Sort(delegate (Period x, Period y) { return x.StartTime.CompareTo(y.StartTime); }); start = new DateTime(DateTime.Now.AddMonths(-3).Year, DateTime.Now.AddMonths(-3).Month, 1); for (int i = 0; i < periodList.Count; i++) { cmbPeriod.Items.Add(periodList[i]); if (start >= periodList[i].StartTime && start < periodList[i].EndTime) { cmbPeriod.SelectedIndex = i; } } } private void Dgv_CellDoubleClick(object sender, DataGridViewCellEventArgs e) { if (e.ColumnIndex == colLine.Index) { DataGridViewCell cell = dgv.Rows[e.RowIndex].Cells[e.ColumnIndex]; int lineId = (int)cell.Tag; CA_Line line = CA_LineFactory.Instance.GetObject(lineId); if (line == null) return; UCLineLayout uc = new UCLineLayout(line.Id, true); GUIUtil.PopupUC(uc, Db.Lang.getString("LINE_LAYOUT", line.Name)); } else if (e.ColumnIndex == colPoint.Index || e.ColumnIndex == colVolumeChange.Index || e.ColumnIndex == colOriginalInjection.Index) { DataGridViewCell cell = dgv.Rows[e.RowIndex].Cells[colPoint]; CA_Point p = (CA_Point)cell.Tag; if (p == null) return; Period period = (Period)cmbPeriod.Items[cmbPeriod.SelectedIndex]; List<CA_Point> points = new List<CA_Point>(); if (p.ObjTypeId == CA_PointFactory.Receipt.Id) { points.Add(p); } else if (p.ObjTypeId == CA_PointFactory.Municipality.Id) { points = CA_PointConfigforBalanceFactory.Instance.GetPoints(p.Id); } if (points != null && points.Count > 0) { UCDailyPointBalanceDetails uc = new UCDailyPointBalanceDetails(period, points, CLASS_NAME); GUIUtil.PopupUC(uc, Db.Lang.getString("Daily Point Balance")); } } } private void btnRecalc_Click(object sender, EventArgs e) { int? networkId = cmbNetwork.GetSelectedId<CA_Network>(); if (networkId == null) return; Period period = (Period)cmbPeriod.Items[cmbPeriod.SelectedIndex]; BLT_Network bltNetwork = new BLT_Network(); bltNetwork.CalcFlow(networkId.Value, period.StartTime, period.EndTime.AddDays(-1)); GUIUtil.ShowMessageBox(MessageBoxIcon.Information, Db.Lang.getString("Recalculate Finished.")); LoadData(networkId.Value, period.StartTime); } private void AddLineFlows(BLT_Line line, DataGridViewRow parentRow = null) { List<CA_LinePointFlow> lineFlows = _flows.FindAll(t => t.LineId == line.Line.Id); foreach (CA_LinePointFlow flow in lineFlows) { CA_Point p = _points.Find(t => t.Id == flow.PointId); if (p == null) continue; int i = dgv.Rows.Add(); DataGridViewRow row = dgv.Rows[i]; if (parentRow != null) { row.ParentRow = parentRow; } row[colLine].Value = line.Line.Name; row[colLine].Tag = line.Line.Id; if (p != null) { ObjType pointType = Sys.ObjTypeCache.GetObjTypeByTypeId(p.ObjTypeId); row[colPointType].Style.BackColor = GUIUtil.Hex2Color(pointType.Color); row[colPointType].Value = pointType.Code; row[colPointType].ToolTipText = Db.Lang.getString(pointType.Name); row[colPoint].Value = p.Name; row[colPoint].Tag = p; } // get list of previous points List<CA_LinePoint> linePoints = line.LinePoints.FindAll(t => t.PointId == flow.PointId && t.PrevPointId.HasValue); string prevPoints = ""; foreach(CA_LinePoint lp in linePoints) { CA_Point p1 = _points.Find(t => t.Id == lp.PrevPointId); if (p1 == null) continue; prevPoints += p1.Name + ","; } if (prevPoints.Length > 0) prevPoints = prevPoints.Remove(prevPoints.Length - 1); row[colPrevPoint].Value = prevPoints; row[colFromPrevPoint].Value = dgv.GetUnit(colFromPrevPoint.Name).Format(flow.VolumeFromPrevPoint); row[colVolumeChange].Value = dgv.GetUnit(colVolumeChange.Name).Format(flow.VolumeChange); row[colVolumePassThru].Value = dgv.GetUnit(colVolumePassThru.Name).Format(flow.VolumePassThru); row[colOriginalInjection].Value = dgv.GetUnit(colOriginalInjection.Name).Format(flow.VolumeChangeOriginal); if (p.ObjTypeId == CA_PointFactory.Line.Id) { BLT_Line nextLine = _lines.Find(t => t.Line.Id != line.Line.Id && t.StartPoint != null && t.StartPoint.Id == p.Id); if (nextLine != null) { AddLineFlows(nextLine, row); } } } } private void btnReport_Click(object sender, EventArgs e) { int? networkId = cmbNetwork.GetSelectedId<CA_Network>(); if (networkId == null) return; Period period = (Period)cmbPeriod.Items[cmbPeriod.SelectedIndex]; UCTransportTaxMunicipality uc = new UCTransportTaxMunicipality(networkId.Value, period.Id); GUIUtil.PopupUC(uc, Db.Lang.getString("Report")); } } } using NQDF.Logger; using S2.CA.DataFactory; using S2.Core.DataFactory; using S2.Core.Entities; using S2.Core.PropertyEditors; using S2.Core.Utils; using S2.MA.DataFactory; using S2.MA.Entities; using System; using System.Collections.Generic; using System.Drawing; using System.Linq; using System.Text; using System.Threading.Tasks; namespace S2.CA.Entities { public class BLT_Network : BLT_ObjBase { public List<CA_Network> Networks; public List<CA_Segment> Segments; public List<CA_Point> Points; private List<CA_PointConfigforBalance> _subPoints; // 2025.5.3, WL, added to cache references public List<CA_Line> Lines; public List<Organization> Organizations; BLT_ObjProp _propsTransporter; BLT_ObjProp _propsRouteCapacityEnable; BLT_ObjProp _propsCapacity; //private static BLT_ObjProp _propsTrunkline; BLT_ObjProp _propsLineActive; private int _decimalsVolume = 0; public BLT_Network() { // Get decimals to round volume for Transport Tax volume calculation BLT_UnitProfile _bltUP = new BLT_UnitProfile(); Unit unitVol = _bltUP.GetUnit("VolumeTransportTax"); if (unitVol != null && unitVol.Decimals.HasValue) _decimalsVolume = unitVol.Decimals.Value; Networks = CA_NetworkFactory.Instance.GetAllObjects("Name"); Segments = CA_SegmentFactory.Instance.GetAllObjects("Name"); Lines = CA_LineFactory.Instance.GetAllObjects("NetworkId, Name"); Points = CA_PointFactory.Instance.GetAllObjects("Name"); _subPoints = CA_PointConfigforBalanceFactory.Instance.GetAllObjects(); Organizations = OrganizationFactory.Instance.GetAllObjects("Name"); _propsTransporter = new BLT_ObjProp("CA_Network", "Transporter"); _propsLineActive = new BLT_ObjProp("CA_Line", "Active"); _propsRouteCapacityEnable = new BLT_ObjProp("CA_Network", "ROUTE_CAPACITY_ENABLED"); _propsCapacity = new BLT_ObjProp("CA_Network", "CAPACITY"); } public Organization GetTransporter(int networkId, DateTime? d = null) { CA_Network network = Networks.Find(t => t.Id == networkId); if (network == null) return null; //DFV - Feb 2024: Fix to avoid exception if Transporter property is not needed/not configured for network object because single transporter or single network if (_propsTransporter.PropTypeList == null || _propsTransporter.PropTypeList.Count <= 0) return null; return Organizations.Find(t => t.Id == _propsTransporter.GetObjPropValueInt(network.Id, network.ObjTypeId, d)); } public Decimal? GetCapacity(int networkId, DateTime? d = null) { CA_Network network = Networks.Find(t => t.Id == networkId); if (network == null) return null; //DFV - Feb 2024: Fix to avoid exception if Transporter property is not needed/not configured for network object because single transporter or single network if (_propsCapacity.PropTypeList == null || _propsCapacity.PropTypeList.Count <= 0) return null; return _propsCapacity.GetObjPropValueDecimal(network.Id, network.ObjTypeId, d); } /// <summary> /// Get list of networks with authority /// </summary> /// <param name="authorityId"></param> /// <param name="d"></param> /// <returns></returns> public List<CA_Network> GetNetworksAsTransporter(int? authorityId = null, DateTime? d = null) { if (authorityId == null) authorityId = CA_Authority.ViewService; List<CA_Network> networks = new List<CA_Network>(); foreach(CA_Network network in Networks) { Organization org = GetTransporter(network.Id, d); if (org == null) { //DFV Oct 2024: If Transporter ORG is not defined (equal to null) the network should be skipped, not added by default //This may cause compatibility issue if the system does not use the TRANSPORTER property for CA_Network and it means //It uses the MasterOrgId instead (single network or single master organization) //Otherwise, for these cases (single network or single master organization) the system will cause any shipper to access all //shippers information when called from GetOrgsWithAuthority method in CA_ContractFactory //networks.Add(network); continue; } if ((Sys.UserAuthorityCache.MasterOrganizationId > 0 && Sys.UserAuthorityCache.HasAuthorityOfMaterOrg(authorityId.Value)) || Sys.UserAuthorityCache.HasAuthorityWithOrgId(org.Id, authorityId.Value)) networks.Add(network); } return networks; } /// <summary> /// 2024.4.16, WL, get list of transporters with authority and effective date /// default value: /// authority - ViewService /// date - today /// </summary> /// <param name="d"></param> /// <returns></returns> public List<Organization> GetTransporters(int? authorityId = null, DateTime? d = null) { if (authorityId == null) authorityId = CA_Authority.ViewService; List<Organization> orgs = new List<Organization>(); foreach (CA_Network network in Networks) { Organization org = GetTransporter(network.Id, d); if (org == null) continue; if (Sys.UserAuthorityCache.HasAuthorityOfMaterOrg(authorityId.Value) || Sys.UserAuthorityCache.HasAuthorityWithOrgId(org.Id, authorityId.Value)) orgs.Add(org); } return orgs; } #region Lines /// <summary> /// Get list of active trunklines of the network by date /// </summary> /// <param name="networkId"></param> /// <param name="date"></param> /// <returns></returns> public List<BLT_Line> GetTrunkline(int networkId, DateTime? date = null) { List<BLT_Line> lines = new List<BLT_Line>(); CA_Network network = Networks.Find(t => t.Id == networkId); if (network == null) return lines; if (date == null) date = DateTime.Now.Date; foreach(CA_Line line in Lines.FindAll(t=> t.ObjTypeId == CA_LineFactory.Trunkline.Id)) { bool? active = _propsLineActive.GetObjPropValueBool(line.Id, line.ObjTypeId, date); if (active.HasValue && active.Value) lines.Add(new BLT_Line(line.Id)); } return lines; } public List<BLT_Line> GetLines(BLT_Line trunkline, DateTime? date = null) { if (date == null) date = DateTime.Now.Date; List<BLT_Line> bltLines = new List<BLT_Line>(); bltLines.Add(trunkline); bltLines.AddRange(GetAllBranches(trunkline, date.Value, GetActiveLines(date))); return bltLines; } public List<CA_Point> GetLinePoints(List<BLT_Line> lines) { List<CA_Point> points = new List<CA_Point>(); foreach(BLT_Line line in lines) { foreach(CA_Point lp in line.Points) { if (points.Exists(t => t.Id == lp.Id)) continue; points.Add(lp); } } return points; } private List<CA_LinePointFlow> _linePointFlows; /// <summary> /// 2024.4.4, WL /// Entry point of flow calculation from trunkline /// Change to new method based on municipality and receipt point connectivities only /// delivery points are configured as subpoint of municipality point and no need to calculate each flow /// Steps: /// 1. Find lines and linepoints /// 2. For each municipality points, get total delivery /// 3. Calculate flow through each city by line points /// 4. Totalize gas flow into the city /// a. For trunkline, when the flow from prev point is positive or flow from next points is negative /// b. For deviation (branch), when the flow from prev points is negative or flow from next points is positive /// </summary> /// <param name="dStart"></param> /// <param name="dEnd"></param> public int CalcFlow(int networkId, DateTime dStart, DateTime dEnd) { LogHelper.Debug("CalcFlow", "Start..."); _linePointFlows = new List<CA_LinePointFlow>(); CA_LinePointFlowFactory.Instance.Delete(networkId, dStart, dEnd); // Calculate from branches List<BLT_Line> trunklines = GetTrunkline(networkId, dStart); int flowCount = 0; foreach(BLT_Line trunkline in trunklines) { flowCount += CalcFlowByTrunkline(trunkline, dStart, dEnd); } return flowCount; } public int CalcFlowByTrunkline(BLT_Line trunkline, DateTime dStart, DateTime dEnd) { // Calculate from branches // Delete all existing data // Get list of points by types of Receipt, Delivery, Consumption, Compressor, Branch, Municipality) // List<BLT_Line> lines = GetLines(trunkline, dStart); List<CA_Point> points = GetLinePoints(lines); points.RemoveAll(t => t.ObjTypeId != CA_PointFactory.Receipt.Id && t.ObjTypeId != CA_PointFactory.Delivery.Id && t.ObjTypeId != CA_PointFactory.Line.Id && t.ObjTypeId != CA_PointFactory.Municipality.Id); if (points.Count == 0) return 0; // Get total balance of points Dictionary<int, decimal> receiptPointVolumes = GetOrignalReceiptPointVolumes(points, dStart, dEnd); Dictionary<int, decimal> pointVolumes = GetPointVolumes(points, dStart, dEnd); // Get volumes per point to line // foreach (BLT_Line line in lines) { GetLinePointFlows(line, pointVolumes); } LogHelper.Debug("CalcFlow", "Finish: GetLinePointFlows"); // Track volumes from connected lines GetLineFlows(trunkline, lines); LogHelper.Debug("CalcFlow", "Finish: GetLineFlows"); // Totalize prevVolume to point List<CA_LinePointFlow> flows = TotalizeFlows(lines, _linePointFlows); LogHelper.Debug("CalcFlow", "Finish: TotalizeFlows"); //List<CA_LinePointFlow> flows = _linePointFlows; // Save foreach (CA_LinePointFlow flow in flows) { // save with networkId for easier query and report flow.NetworkId = trunkline.Line.NetworkId; // save orgId for easier query and report // 2024.4.4, WL, save orgPointId, the orgPointId with positive flow from prev point CA_Point p = points.Find(t => t.Id == flow.PointId); if (p.ObjTypeId == CA_PointFactory.Municipality.Id && p.SwingShipper.HasValue) { flow.OrgId = p.SwingShipper; } flow.StartDate = dStart; flow.EndDate = dEnd; flow.CreateTime = DateTime.Now; if (receiptPointVolumes.ContainsKey(flow.PointId)) { flow.VolumeChangeOriginal = receiptPointVolumes[flow.PointId]; } // 2024.4.4, WL, Calculate volume passthru for Municipality point // If volume is positive // abs(volume change) is greater than if (p.ObjTypeId == CA_PointFactory.Municipality.Id) { if (!flow.VolumeChange.HasValue) flow.VolumeChange = 0; if (!flow.VolumeFromPrevPoint.HasValue) flow.VolumeFromPrevPoint = 0; if (flow.VolumeFromPrevPoint > 0) { if (Math.Abs(flow.VolumeChange.Value) >= flow.VolumeFromPrevPoint) { flow.VolumePassThru = Math.Abs(flow.VolumeChange.Value); } else flow.VolumePassThru = flow.VolumeFromPrevPoint; } else { flow.VolumePassThru = Math.Abs(flow.VolumeFromPrevPoint.Value + flow.VolumeChange.Value); } } flow.Save(null, false); } return flows.Count; } /// <summary> /// Get volumes of each point /// Balance volumes of receipt to delivery /// if total(receipt) > total(delivery), set total(receipt) = total(delivery) and reduce receipt per point by proportionl /// if total(receipt> < total(delivery), TODO: maybe popup a warning, this should never happen? /// </summary> /// <param name="points"></param> /// <param name="dStart"></param> /// <param name="dEnd"></param> /// <returns></returns> private Dictionary<int, decimal> GetPointVolumes(List<CA_Point> points, DateTime dStart, DateTime dEnd) { List<CA_DailyPointBalance> pbList = CA_DailyPointBalanceFactory.Instance.GetLatestDailyPointBalances(dStart, dEnd, CA_Enums.Cycle.EndOfMonth).FindAll(t=> t.Volume.HasValue && t.Volume > 0); if (pbList == null || pbList.Count == 0) return null; // Get receipt decimal totalReceipt = 0m; Dictionary<int, decimal> receiptVolumes = new Dictionary<int, decimal>(); foreach (CA_Point point in points.FindAll(t => t.ObjTypeId == CA_PointFactory.Receipt.Id)) { decimal? volume = pbList.FindAll(t => t.PointId == point.Id).Sum(t => t.Volume); if (volume.HasValue) { receiptVolumes.Add(point.Id, volume.Value); totalReceipt += volume.Value; } } // Totalize delivery by municipality decimal totalDelivery = 0m; Dictionary<int, decimal> pointVolumes = new Dictionary<int, decimal>(); List<CA_PointConfigforBalance> subPoints = CA_PointConfigforBalanceFactory.Instance.GetAllObjects(); foreach (CA_Point point in points.FindAll(t => t.ObjTypeId == CA_PointFactory.Municipality.Id)) { decimal totalVol = 0; List<CA_PointConfigforBalance> mySubPoints = subPoints.FindAll(t => t.Point1 == point.Id); if (mySubPoints.Count > 0) { foreach(CA_PointConfigforBalance subPoint in mySubPoints) { CA_Point point2 = Points.Find(p => p.Id == subPoint.Point2); if (point2 == null || point2.ObjTypeId != CA_PointFactory.Delivery.Id) continue; totalVol += pbList.FindAll(t => t.PointId == point2.Id).Sum(t => Math.Round(t.Volume.Value * -1, _decimalsVolume)); } } pointVolumes.Add(point.Id, totalVol); totalDelivery += totalVol * -1; } //if (totalDelivery <= 0) return null; // Alight receipt volumes to delivery if (totalReceipt > 0) { foreach (int pointId in receiptVolumes.Keys.ToList()) { pointVolumes.Add(pointId, Math.Round(receiptVolumes[pointId] * totalDelivery / totalReceipt, _decimalsVolume)); } } return pointVolumes; } private Dictionary<int, decimal> GetOrignalReceiptPointVolumes(List<CA_Point> points, DateTime dStart, DateTime dEnd) { Dictionary<int, decimal> pointVolumes = new Dictionary<int, decimal>(); // 2025.3.18, PRMCGA-325, WL // Get latest volume <= Monthly Cycle List<CA_DailyPointBalance> pbList = CA_DailyPointBalanceFactory.Instance.GetLatestDailyPointBalances(dStart, dEnd, CA_Enums.Cycle.EndOfMonth).FindAll(t => t.Volume.HasValue && t.Volume > 0); if (pbList == null || pbList.Count == 0) return pointVolumes; // Get receipt foreach (CA_Point point in points.FindAll(t => t.ObjTypeId == CA_PointFactory.Receipt.Id)) { decimal? volume = pbList.FindAll(t => t.PointId == point.Id).Sum(t => t.Volume); if (volume.HasValue) { pointVolumes.Add(point.Id, volume.Value); } } return pointVolumes; } private void GetLinePointFlows(BLT_Line line, Dictionary<int, decimal> volumes) { //LogHelper.Debug("BLT_Network", "GetLinePointFlows: Line=" + line.Line.Name); foreach (CA_Point point in line.Points) { if (!volumes.ContainsKey(point.Id)) continue; GetPointFlows(line, point, volumes[point.Id]); } } private void GetPointFlows(BLT_Line line, CA_Point point, decimal volume) { //LogHelper.Debug("BLT_Network", "GetPointFlows: Line=" + line.Line.Name + ", Point=" + point.Name); CA_LinePointFlow flow = new CA_LinePointFlow(); flow.LineId = line.LineId; flow.PointId = point.Id; flow.VolumeChange = volume; _linePointFlows.Add(flow); GetFlowThroughVolumes(line, point, point, volume); } private void GetFlowThroughVolumes(BLT_Line line, CA_Point origPoint, CA_Point point, decimal volume) { if (origPoint == null || point == null) { return; } List<CA_Point> nextPoints = null; if (line.Line.ObjTypeId == BLT_Line.Trunkline.Id) nextPoints = line.GetNextPoints(point); else nextPoints = line.GetPrevPoints(point); if (nextPoints.Count == 0) return; decimal nextVolume = volume / nextPoints.Count; foreach(CA_Point nextPoint in nextPoints) { if (nextPoint == null) continue; CA_LinePointFlow flow = new CA_LinePointFlow(); flow.LineId = line.LineId; flow.PointId = nextPoint.Id; flow.PrevPointId = origPoint.Id; flow.VolumeFromPrevPoint = nextVolume; _linePointFlows.Add(flow); GetFlowThroughVolumes(line, origPoint, nextPoint, nextVolume); } } public List<BLT_Line> GetBranches(BLT_Line line, List<BLT_Line> allLines) { List<BLT_Line> nextLines = new List<BLT_Line>(); if (line.StartPoint == null) return nextLines; List<CA_Point> lineStartPoints = line.Points.FindAll(t => t.Id != line.StartPoint.Id && t.ObjTypeId == CA_PointFactory.Line.Id); foreach (CA_Point point in lineStartPoints) { BLT_Line nextLine = allLines.Find(t => t.Line.StartPointId == point.Id); if (nextLine == null) continue; nextLines.Add(nextLine); } return nextLines; } public List<CA_Line> GetActiveLines(DateTime? date = null) { if (date == null) date = DateTime.Now.Date; List<CA_Line> activeLines = new List<CA_Line>(); foreach(CA_Line line in Lines) { bool? active = _propsLineActive.GetObjPropValueBool(line.Id, line.ObjTypeId, date.Value); if (active != null && active.Value) { activeLines.Add(line); } } return activeLines; } public List<BLT_Line> GetAllBranches(BLT_Line line, DateTime date, List<CA_Line> activeLines) { List<BLT_Line> nextLines = new List<BLT_Line>(); List<CA_Point> lineStartPoints = line.Points.FindAll(t => t.Id != line.Line.StartPointId && t.ObjTypeId == CA_PointFactory.Line.Id); foreach (CA_Point point in lineStartPoints) { CA_Line line1 = activeLines.Find(t => t.StartPointId == point.Id); if (line1 == null) continue; BLT_Line nextLine = new BLT_Line(line1.Id); nextLines.Add(nextLine); nextLines.AddRange(GetAllBranches(nextLine, date, activeLines)); } return nextLines; } /// <summary> /// Find connected lines by start points /// foreach connected line /// find connected lines by start points /// </summary> /// <param name="bltLine"></param> /// <param name="linePointVolumes"></param> /// <returns></returns> private void GetLineFlows(BLT_Line bltLine, List<BLT_Line> allLines) { List<BLT_Line> nextLines = GetBranches(bltLine, allLines); if (nextLines.Count == 0) return; foreach (BLT_Line nextLine in nextLines) { // go to downstream lines if (!_linePointFlows.Exists(t => t.LineId == bltLine.Line.Id && t.PointId == nextLine.Line.StartPointId && t.PrevPointId == null)) GetLineFlows(nextLine, allLines); } // Get volume at start point of each branch foreach (BLT_Line nextLine in nextLines) { decimal volume = 0; foreach (CA_LinePointFlow flow in _linePointFlows.FindAll(t => t.LineId == nextLine.Line.Id && t.PointId == nextLine.Line.StartPointId)) { volume += flow.VolumeFromPrevPoint.Value; } CA_LinePointFlow lineFlow = new CA_LinePointFlow(); lineFlow.LineId = bltLine.Line.Id; lineFlow.PointId = nextLine.Line.StartPointId; lineFlow.VolumeChange = volume; _linePointFlows.Add(lineFlow); // go downstream (trunkline) or upstream (branch) GetFlowThroughVolumes(bltLine, nextLine.StartPoint, nextLine.StartPoint, volume); } } private List<CA_LinePointFlow> TotalizeFlows(List<BLT_Line> lines, List<CA_LinePointFlow> flows) { List<CA_LinePointFlow> totalflows = new List<CA_LinePointFlow>(); foreach(BLT_Line line in lines) { List<CA_LinePointFlow> lineFlows = flows.FindAll(t => t.LineId == line.LineId); if (lineFlows.Count == 0) continue; foreach(CA_Point point in line.Points) { CA_LinePointFlow pointFlow = new CA_LinePointFlow(); pointFlow.LineId = line.LineId; pointFlow.PointId = point.Id; decimal? vol = lineFlows.FindAll(t => t.PointId == point.Id).Sum(f => f.VolumeFromPrevPoint); if (vol.HasValue && vol != 0m) pointFlow.VolumeFromPrevPoint = vol ; vol = lineFlows.Find(t => t.PointId == point.Id && !t.PrevPointId.HasValue)?.VolumeChange; if (vol.HasValue && vol != 0m) pointFlow.VolumeChange = vol; totalflows.Add(pointFlow); } } return totalflows; } #endregion #region Segments public List<CA_Segment> GetSegments(int? networkId = null) { return Segments.FindAll(s1 => networkId == null || s1.NetworkId == networkId.Value); } public List<CA_Segment> GetSegments(List<CA_Network> networks, int? objTypeId = null) { return Segments.FindAll(s1 => networks.Exists(n => n.Id == s1.NetworkId) && (objTypeId == null || s1.ObjTypeId == objTypeId.Value)); } #endregion #region SubPoints public List<int> GetSubPoints(int pointId) { return _subPoints?.FindAll(t => t.Point1 == pointId).Select(t=> t.Point2).ToList(); } public int? GetParentPoint(int pointId) { return _subPoints?.Find(t => t.Point2 == pointId)?.Point1; } #endregion } }